#include "wattle_client.hpp"
#include "wattle-cxx/src/lib.rs.h" // Generated by cxx
#include <stdexcept>
#include <iostream>

namespace wattle {

Client::Client(const std::string& workflow_name, const std::string& worker_name) {
    try {
        auto result = new_wattle_client(workflow_name, worker_name);
        client_ = std::move(result);
    } catch (const WattleError& e) {
        throw std::runtime_error("Failed to create Wattle client: " + e.message);
    }
}

Client::~Client() {
    if (client_) {
        cleanup_client(*client_);
    }
}

Client::Client(Client&& other) noexcept : client_(std::move(other.client_)) {}

Client& Client::operator=(Client&& other) noexcept {
    if (this != &other) {
        if (client_) {
            cleanup_client(*client_);
        }
        client_ = std::move(other.client_);
    }
    return *this;
}

bool Client::publishJson(const std::string& service_name, const std::string& json_data) {
    if (!client_) {
        last_error_ = "Client not initialized";
        return false;
    }

    auto response = publish_json(*client_, service_name, json_data);
    if (!response.success) {
        last_error_ = response.error;
        return false;
    }

    last_error_.clear();
    return true;
}

std::string Client::requestJson(const std::string& target_worker, 
                               const std::string& service_name,
                               const std::string& json_data, 
                               uint32_t timeout_secs) {
    if (!client_) {
        last_error_ = "Client not initialized";
        return "";
    }

    auto response = request_json(*client_, target_worker, service_name, json_data, timeout_secs);
    if (!response.success) {
        last_error_ = response.error;
        return "";
    }

    last_error_.clear();
    return response.data;
}

bool Client::subscribeJson(const std::string& service_name) {
    if (!client_) {
        last_error_ = "Client not initialized";
        return false;
    }

    auto response = subscribe_json(*client_, service_name);
    if (!response.success) {
        last_error_ = response.error;
        return false;
    }

    last_error_.clear();
    return true;
}

std::pair<std::string, std::string> Client::getNextMessage() {
    if (!client_) {
        last_error_ = "Client not initialized";
        return {"", ""};
    }

    auto response = get_next_message(*client_);
    if (!response.success) {
        if (!response.error.empty()) {
            last_error_ = response.error;
        }
        return {"", ""};
    }

    if (response.data.empty()) {
        // No message available
        return {"", ""};
    }

    // Parse the service and data from the response
    // Format: {"service":"service_name","data":json_data}
    try {
        // Simple JSON parsing for the wrapper format
        size_t service_start = response.data.find("\"service\":\"") + 11;
        size_t service_end = response.data.find("\",\"data\":", service_start);
        size_t data_start = response.data.find(":", service_end) + 1;
        size_t data_end = response.data.rfind("}");

        if (service_start != std::string::npos && service_end != std::string::npos &&
            data_start != std::string::npos && data_end != std::string::npos) {
            
            std::string service = response.data.substr(service_start, service_end - service_start);
            std::string data = response.data.substr(data_start, data_end - data_start);
            
            last_error_.clear();
            return {service, data};
        }
    } catch (...) {
        last_error_ = "Failed to parse message format";
    }

    return {"", ""};
}

std::string Client::getLastError() const {
    return last_error_;
}

} // namespace wattle

// Global callback function implementation
void handle_subscription_message(const std::string& service_name, const std::string& json_data) {
    // This is a global callback that can be used for immediate message handling
    // For now, we just print to stdout - applications can override this behavior
    std::cout << "Subscription message received - Service: " << service_name 
              << ", Data: " << json_data << std::endl;
}
